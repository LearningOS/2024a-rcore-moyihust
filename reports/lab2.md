### 实现的功能
使用translated_byte_buffer来实现结构体完整性以完成sys_get_time 和 sys_task_info.然后完成申请内存的检查以及申请的释放。
### 问答

1. **请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？**

   SV39 页表页表项（PTE）由以下部分组成：
   - **PPN (Physical Page Number)**：物理页号，用于指向物理内存中的页。
   - **标志位 (Flags)**：
     - **V (Valid)**：页表项是否有效。
     - **R (Readable)**：页是否可读。
     - **W (Writable)**：页是否可写。
     - **X (Executable)**：页是否可执行。
     - **U (User)**：用户模式是否可以访问该页。
     - **G (Global)**：全局页，不会在上下文切换时刷新 TLB。
     - **A (Accessed)**：页是否被访问过。
     - **D (Dirty)**：页是否被写过。

2. **缺页**

   缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断，告知 OS 进程内存访问出了问题。OS 选择填补页表并重新执行异常指令或者杀死进程。

   - **请问哪些异常可能是缺页导致的？**
     - 页面不存在异常（Page Not Present）
     - 页面保护异常（Page Protection Fault）

   - **发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。**
     - **`stval`**：保存导致异常的虚拟地址。
     - **`scause`**：保存异常的原因代码。
     - **`sepc`**：保存导致异常的指令地址。

   缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 OS 并不会马上这样做，而是会保存 `.text` 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。

   - **这样做有哪些好处？**
     - 减少内存占用：只有在实际访问时才分配内存，避免不必要的内存分配。
     - 提高性能：减少启动时的内存加载时间。

   - **处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？**
     - 每个页表项占用 8 字节，一个页表可以映射 512 个页。10G 内存大约需要 2,560,000 个页表项，因此需要大约 20 MB 的内存来存储页表。

   - **请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。**
     - 实现 Lazy 策略的方法是，在内存分配时只记录需要分配的内存区域，而不实际分配物理内存。当发生缺页异常时，OS 捕获异常并分配实际的物理内存，然后更新页表并重新执行导致异常的指令。

   缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。

   - **此时页面失效如何表现在页表项 (PTE) 上？**
     - 页表项中的 Valid 位被清除，表示该页不在内存中。

3. **双页表与单页表**

   为了防范侧信道攻击，我们的 OS 使用了双页表。但是传统的设计一直是单页表的，也就是说，用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。

   - **在单页表情况下，如何更换页表？**
     - 在单页表情况下，更换页表通常通过修改页表基地址寄存器（如 `satp` 寄存器）来实现。

   - **单页表情况下，如何控制用户态无法访问内核页面？**
     - 通过设置页表项中的 User 位（U 位），确保内核页面的 U 位为 0，这样用户态无法访问这些页面。

   - **单页表有何优势？**
     - 减少页表切换的开销，提高性能。
     - 简化内存管理逻辑。

   - **双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表？**
     - 双页表实现下，在用户态和内核态切换时需要更换页表。
     - 如果使用单页表操作系统，可以在进程切换时更换页表。

### 荣耀准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

2. 此外，我也参考了以下资料，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
    
    - https://hangx-ma.github.io/2023/07/04/rcore-note-ch4.html#42-%E6%94%B9%E8%BF%9B-syscall
    - https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/4sv39-implementation-2.html

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。